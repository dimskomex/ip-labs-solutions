#include <stdio.h>

// Κάνουμε compile γράφοντας:
// gcc -o overflow overflow.c

// Μερικά λόγια για την συμπεριφορά του προγράμματος που δίνεται: η printf με το
// format που δίνεται να εκτυπώσει (%d) πρόκειται να εκτυπώσει μια τιμή τύπου
// int (integer). Για έναν τέτοιο τύπο, δεσμεύονται 4 bytes (32 bits).  Άρα, ο
// ακέραιος αυτός παίρνει τιμές στο σύνολο [-2^31, 2^31 - 1] = [-2,147,483,648,
// 2,147,483,647].  Συνεπώς, η πράξη που εκτελείται βρίσκεται εκτός του συνόλου
// που χωράει σε έναν ακέραιο τύπου int, προκαλώντας overflow.  Ένας τρόπος να
// το λύσουμε αυτό, είναι να βάλουμε τις τιμές σε μεταβλητές διαφορετικού τύπου.
// 2 Τύποι που μας εξυπηρετούν είναι οι: unsigned int & long int.  Ο πρώτος,
// περιέχει αποκλειστικά θετικές τιμές των 4 bytes, άρα με range [0,
// 4294967296].  Ο δεύτερος, δεσμεύει 8 bytes, έχοντας αρκετά μεγαλύτερο range.
// Στην λύση μας, θα χρησιμοποιήσουμε long int.

// Για περισσότερους τύπους, μπορείτε να επισκεφτείτε την παρακάτω πηγή:
// https://www.geeksforgeeks.org/c/ranges-of-data-types-in-c/

int main() {
    printf("%d\n", 2000000000 + 2000000000); // εκτυπώνει -294967296 αντί για 4000000000

    // Η λύση μας:
    long int value_1 = 2000000000;
    long int value_2 = 2000000000;
    printf("%ld\n", value_1 + value_2); // χρησιμοποιούμε format ld που είναι για long int
    return 0;
}