#include <stdio.h>

// Γιατί η συνάρτηση αυτή είναι λάθος?
// Η απάντηση βρίσκεται στο πως συμπεριφέρονται οι συναρτήσεις στην C.
// Η C για κάθε τιμή με την οποία καλείται μία συνάρτηση, δημιουργεί
// νέες μεταβλητές αντίγραφα, δηλαδή, μεταβλητές με την ίδια τιμή.
// Συνεπώς, όλες οι αλλαγές εφαρμόζωνται στα αντίγραφα και όχι στις
// μεταβλητές που χρησιμοποιήθηκαν όταν καλέσαμε την συνάρτηση.
void badf(int x, int y, int sum, int diff) {
    sum = x + y;
    diff = x - y;
}

// Η λύση σε αυτό το πρόβλημα βρίσκεται στους δείκτες.
// Οι δείκτες θα μπορούσαμε να τους σκεφτούμε ως μεταβλητές
// που δείχνουν σε θέσεις μνήμης. Γιατί είναι χρήσιμο όμως αυτό?
// Μία απάντηση βρίσκεται στην goodf!

// Έστω το παρακάτω τμήμα προγράμματος:
/*
int x;
int *px;
px = &x;
*px = 10;
*/

// Αυτό που συμβαίνει παραπάνω, είναι πως μία μεταβλητή δείκτη σε ακέραιο (px)
// παίρνει την διεύθυνση της μεταβλητής (το &x ερμηνεύεται ως η διεύθυνση που
// βρίσκεται το x στην μνήμη) και εκεί που δείχνει ο δείκτης, κάνει την τιμή του
// 10. Οπότε, άμα περνάμε δείκτες στις συναρτήσεις μας, ναι μεν θα δημιουργηθούν
// αντίγραφα για τους δείκτες, αλλά θα δείχνουν στην ίδια διεύθυνση μνήμης.
void goodf(int x, int y, int *sum, int *diff) {
    *sum = x + y;
    *diff = x - y;
}

int main(void) {
    int a, b, sum, diff;
    scanf("%d", &a);
    scanf("%d", &b);
    sum = 0;
    diff = 0;

    badf(a, b, sum, diff);
    printf("sum = %d & diff = %d\n", sum, diff);

    goodf(a, b, &sum, &diff);
    printf("sum = %d & diff = %d\n", sum, diff);

    return 0;
}